<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Jonas Kristoffer Lindeløv" />


<title>Common statistical tests are linear models (or: how to teach stats)</title>

<script src="index_files/jquery-1.12.4/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="index_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="index_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="index_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="index_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="index_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="index_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="index_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="index_files/navigation-1.1/tabsets.js"></script>
<link href="index_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="index_files/highlightjs-9.12.0/highlight.js"></script>
<script src="index_files/htmlwidgets-1.3/htmlwidgets.js"></script>
<link href="index_files/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
<script src="index_files/datatables-binding-0.5/datatables.js"></script>
<link href="index_files/dt-core-1.10.16/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="index_files/dt-core-1.10.16/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="index_files/dt-core-1.10.16/js/jquery.dataTables.min.js"></script>
<link href="index_files/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="index_files/crosstalk-1.0.0/js/crosstalk.min.js"></script>
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@jonaslindeloev">
<meta name="twitter:title" content="Common statistical tests are linear models (or: how to teach stats)">
<meta name="twitter:image" content="https://lindeloev.github.io/tests-as-linear/linear_tests_cheat_sheet.png">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1026978-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  
  gtag('config', 'UA-1026978-2');
</script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Common statistical tests are linear models (or: how to teach stats)</h1>
<h4 class="author">Jonas Kristoffer Lindeløv</h4>

</div>


<style type="text/css">

  body {
    font-size: 17px;
  }
  
  /* HEADING 1 */
  h1 {
    font-size: 28px;
    font-weight: bold;
    padding-top: 20px;
  }
  
  /* HEADING 2 */
  h2 {
    font-size: 24px;
    padding: 0px;
    padding-top: 20px;d
  }
  
  /* First h2 in section */
  .level1 > .level2:nth-child(3) > h2 {
    padding-top: 0px;
  }
  
  /* HEADING 3 */
  h3 {
    font-size: 18px;
    font-weight: bold;
    padding-top: 20px;
  }
  
  /* First h3 in section */
  .level2 > .level3:nth-child(3) > h3 {
    padding-top: 0px;
  }

</style>
<!-- from https://stackoverflow.com/a/37839683/1297830 -->
<link rel="stylesheet" type="text/css" href="hideOutput.css">
<script src="hideOutput.js"></script>
<!-- Twitter share button -->
<a href="https://twitter.com/intent/tweet?text=Common%20statistical%20tests%20are%20linear%20models%20(or:%20how%20to%20teach%20stats)%20https%3A%2F%2Flindeloev.github.io%2Ftests-as-linear%20via%20%40jonaslindeloev" class="twitter-hashtag-button" data-size="large" data-related="jonaslindeloev" data-show-count="false">Share on Twitter</a>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>
</p>
<p>This document is summarised in the table below. It shows the linear models underlying common parametric and non-parametric tests. Formulating all the tests in the same language highlights the many similarities between them. Get it <a href="linear_tests_cheat_sheet.png">as an image</a> or <a href="linear_tests_cheat_sheet.pdf">as a PDF</a>.</p>
<hr />
<p><a href="linear_tests_cheat_sheet.pdf"><img src="linear_tests_cheat_sheet.png" /></a></p>
<hr />
<div id="the-simplicity-underlying-common-tests" class="section level1">
<h1><span class="header-section-number">1</span> The simplicity underlying common tests</h1>
<p>Most of the common statistical models (t-test, correlation, ANOVA; chi-square, etc.) are special cases of linear models or a very close approximation. This beautiful simplicity means that there is less to learn. In particular, it all comes down to <span class="math inline">\(y = a \cdot x + b\)</span> which most students know from highschool. Unfortunately, stats intro courses are usually taught as if each test is an independent tool, needlessly making life more complicated for students and teachers alike.</p>
<p>This needless complexity multiplies when students try to rote learn the parametric assumptions underlying each test separately rather than deducing them from the linear model.</p>
<p>For this reason, I think that teaching linear models first and foremost and <em>then</em> name-dropping the special cases along the way makes for an excellent teaching strategy, emphasizing <em>understanding</em> over rote learning. Since linear models are the same across frequentist, Bayesian, and permutation-based inferences, I’d argue that it’s better to start with modeling than p-values, type-1 errors, Bayes factors, or other inferences.</p>
<p>Concerning the teaching of <em>non-parametric</em> tests in intro-courses, I think that we can justify <a href="https://en.wikipedia.org/wiki/Lie-to-children">lying-to-children</a> and teach non-parametric tests as if they are merely ranked versions of the corresponding parametric tests. It is much better for students to think “ranks!” than to believe that you can magically throw away assumptions. Indeed, the Bayesian equivalents of non-parametric tests implemented in <a href="https://jasp-stats.org">JASP</a> <a href="https://arxiv.org/abs/1712.06941">literally just do (latent) ranking</a> and that’s it. For the frequentist non-parametric tests considered here, this approach is highly accurate for N &gt; 15.</p>
<p>Use the menu to jump to your favourite section. There are links to lots of similar (though more scattered) stuff under <a href="#links">sources</a> and <a href="#course">teaching materials</a>. I hope that you will join in suggesting improvements or submitting improvements yourself in <a href="https://github.com/lindeloev/tests-as-linear">the Github repo to this page</a>. Let’s make it awesome!</p>
</div>
<div id="settings-and-toy-data" class="section level1">
<h1><span class="header-section-number">2</span> Settings and toy data</h1>
Unfold this if you want to see functions and other settings for this notebook:
<div class="fold s">
<pre class="r"><code># Load packages for data handling and plotting
library(tidyverse)
library(patchwork)
library(broom)

# Reproducible &quot;random&quot; results
set.seed(40)

# To show tables. Rounds
print_df = function(D, decimals=4, navigate=FALSE) {
  DT::datatable(mutate_if(D, is.numeric, round, decimals), 
    rownames = FALSE,
    options = list(
      searching=FALSE, 
      lengthChange=FALSE, 
      ordering=FALSE, 
      autoWidth=TRUE, 
      bPaginate=navigate, 
      bInfo=navigate, 
      paging=navigate
    )
  )
}

# Generate normal data with known parameters
rnorm_fixed = function(N, mu=0, sd=1) scale(rnorm(N))*sd + mu

# Plot style.
theme_axis = function(P, jitter=FALSE, xlim=c(-0.5, 2), ylim=c(-0.5, 2), legend.position=NULL) {
  P = P + theme_bw(15) + 
  geom_segment(x=-1000, xend=1000, y=0, yend=0, lty=2, color=&#39;dark gray&#39;, lwd=0.5) +
  geom_segment(x=0, xend=0, y=-1000, yend=1000, lty=2, color=&#39;dark gray&#39;, lwd=0.5) +
  coord_cartesian(xlim=xlim, ylim=ylim) +
  theme(axis.title = element_blank(), 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        legend.position = legend.position)
  
  # Return jittered or non-jittered plot?
  if(jitter) {
    P + geom_jitter(width=0.1, size=2)
  }
  else {
    P + geom_point(size=2)
  }
}</code></pre>
</div>
<p>For a start, we’ll keep it simple and play with three standard normals in wide (<code>a</code>, <code>b</code>, <code>c</code>) and long format (<code>value</code>, <code>group</code>):</p>
<pre class="r"><code># Wide format (sort of)
y = rnorm_fixed(50, mu=0.3, sd=2)  # Almost zero mean
x = rnorm_fixed(50, mu=0, sd=1)  # Used in correlation where this is on x-axis
y2 = rnorm_fixed(50, mu=0.5, sd=1.5)  # Used in two means

# Long format data with indicator
value = c(y, y2)
group = rep(c(&#39;y1&#39;, &#39;y2&#39;), each = 50)

# We&#39;ll need the signed rank function for a lot of the &quot;non-parametric&quot; tests
signed_rank = function(x) sign(x) * rank(abs(x))</code></pre>
</div>
<div id="correlation" class="section level1">
<h1><span class="header-section-number">3</span> Pearson and Spearman correlation</h1>
<div id="theory-as-linear-models" class="section level3">
<h3><span class="header-section-number">3.0.1</span> Theory: As linear models</h3>
<p>Model: the recipe for <span class="math inline">\(y\)</span> is a slope (<span class="math inline">\(\beta_1\)</span>) times <span class="math inline">\(x\)</span> plus an intercept (<span class="math inline">\(\beta_0\)</span>, aka a straight line).</p>
<p><span class="math inline">\(y = \beta_0 + \beta_1 x \qquad \mathcal{H}_0: \beta_1 = 0\)</span></p>
<p>… which is a math-y way of writing the good old <span class="math inline">\(y = ax + b\)</span> (here ordered as <span class="math inline">\(y = b + ax\)</span>). In R we are lazy and write <code>y ~ 1 + x</code> which R reads like <code>y = 1*number + x*othernumber</code> and the task of t-tests, lm, etc., is simply to find the numbers that best predict <span class="math inline">\(y\)</span>.</p>
<p>Either way you write it, it’s an intercept (<span class="math inline">\(\beta_0\)</span>) and a slope (<span class="math inline">\(\beta_1\)</span>) yielding a straight line:</p>
<div class="fold s">
<pre class="r"><code># Fixed correlation
D_correlation = data.frame(MASS::mvrnorm(30, mu=c(0.9, 0.9), Sigma=matrix(c(1, 0.8, 1, 0.8), ncol=2), empirical=TRUE))  # Correlated data

# Add labels (for next plot)
D_correlation$label_num = sprintf(&#39;(%.1f,%.1f)&#39;, D_correlation$X1, D_correlation$X2)
D_correlation$label_rank = sprintf(&#39;(%i,%i)&#39;, rank(D_correlation$X1), rank(D_correlation$X2))

# Plot it
fit = lm(I(X2*0.5+0.4) ~ I(X1*0.5+0.2), D_correlation)
intercept_pearson = coefficients(fit)[1]

P_pearson = ggplot(D_correlation, aes(x=X1*0.5+0.2, y=X2*0.5+0.4)) +
  geom_smooth(method=lm, se=FALSE, lwd=2, aes(colour=&#39;beta_1&#39;)) + 
  geom_segment(x=-100, xend=100, 
               y=intercept_pearson, yend=intercept_pearson, 
               lwd=2, aes(color=&quot;beta_0&quot;)) + 
  scale_color_manual(name=NULL, values=c(&quot;blue&quot;, &quot;red&quot;), labels=c(bquote(beta[0]*&quot; (intercept)&quot;), bquote(beta[1]*&quot; (slope)&quot;)))
  
theme_axis(P_pearson, legend.position=c(0.4, 0.9))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<p>This is often simply called a <strong>regression</strong> model which can be extended to <strong>multiple regression</strong> where there are several <span class="math inline">\(\beta\)</span>s and on the right-hand side multiplied with the predictors. Everything below, from <a href="#t1">one-sample t-test</a> to <a href="#anova2">two-way ANOVA</a> are just special cases of this system. Nothing more, nothing less.</p>
<p>As the name implies, the <strong>Spearman rank correlation</strong> is a <strong>Pearson correlation</strong> on rank-transformed <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>:</p>
<p><span class="math inline">\(rank(y) = \beta_0 + \beta_1 \cdot rank(x) \qquad \mathcal{H}_0: \beta_1 = 0\)</span></p>
<p>The correlation coefficient of the linear model is identical to a “real” Pearson correlation, but p-values are an approximation which is is <a href="simulate_spearman.html">appropriate for samples greater than N=10 and almost perfect when N &gt; 20</a>. Such a nice and non-mysterious equivalence that many students are left unaware of! Visualizing them side by side including data labels, we see this rank-transformation in action:</p>
<div class="fold s">
<pre class="r"><code># Spearman intercept
intercept_spearman = coefficients(lm(rank(X2) ~ rank(X1), D_correlation))[1]

# Spearman plot
P_spearman = ggplot(D_correlation, aes(x=rank(X1), y=rank(X2))) +
  geom_smooth(method=lm, se=FALSE, lwd=2, aes(color=&#39;beta_1&#39;)) + 
  geom_text(aes(label=label_rank), nudge_y=1, size=3, color=&#39;dark gray&#39;) + 
  geom_segment(x=-100, xend=100, 
               y=intercept_spearman, yend=intercept_spearman, 
               lwd=2, aes(color=&#39;beta_0&#39;)) + 
  scale_color_manual(name=NULL, values=c(&quot;blue&quot;, &quot;red&quot;), labels=c(bquote(beta[0]*&quot; (intercept)&quot;), bquote(beta[1]*&quot; (slope)&quot;)))

# Stich together using patchwork
(theme_axis(P_pearson, legend.position=c(0.5, 0.1)) + geom_text(aes(label=label_num), nudge_y=0.1, size=3, color=&#39;dark gray&#39;) + labs(title=&#39;         Pearson&#39;)) + (theme_axis(P_spearman, xlim=c(-7.5, 30), ylim=c(-7.5, 30), legend.position=c(0.5, 0.1)) + labs(title=&#39;         Spearman&#39;))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" width="768" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="r-code-pearson-correlation" class="section level3">
<h3><span class="header-section-number">3.0.2</span> R code: Pearson correlation</h3>
<p>It couldn’t be much simpler to run these models in R. They yield identical <code>p</code> and <code>t</code>, but there’s a catch: <code>lm</code> gives you the <em>slope</em> and even though that is usually much more interpretable and informative than the <em>correlation coefficient</em> <em>r</em>, you may still want <em>r</em>. Luckily, the slope becomes <code>r</code> if <code>x</code> and <code>y</code> have a standard deviation of exactly 1. You can do this using <code>scale(x)</code> or <code>I(x/sd(x))</code>:</p>
<pre class="r"><code>a = cor.test(y, x, method = &quot;pearson&quot;) # Built-in
b = lm(y ~ 1 + x) # Equivalent linear model: y = Beta0*1 + Beta1*x
c = lm(scale(y) ~ 1 + scale(x))  # On scaled vars to recover r</code></pre>
Results: <div id="htmlwidget-58f61054e232de0dbaf9" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-58f61054e232de0dbaf9">{"x":{"filter":"none","data":[["cor.test","lm","lm scaled"],[-0.2318,-0.4636,-0.2318],[0.1053,0.1053,0.1053],[-1.6507,-1.6507,-1.6507],[-0.4792,-1.0282,-0.5141],[0.0498,0.1011,0.0505]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>r<\/th>\n      <th>p.value<\/th>\n      <th>t<\/th>\n      <th>conf.low<\/th>\n      <th>conf.high<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Pearson&#39;s product-moment correlation
## 
## data:  y and x
## t = -1.6507, df = 48, p-value = 0.1053
## alternative hypothesis: true correlation is not equal to 0
## 95 percent confidence interval:
##  -0.47920849  0.04978276
## sample estimates:
##        cor 
## -0.2317767 
## 
## 
## Call:
## lm(formula = y ~ 1 + x)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.3393 -1.6593  0.3349  1.3629  3.5214 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)   0.3000     0.2780   1.079    0.286
## x            -0.4636     0.2808  -1.651    0.105
## 
## Residual standard error: 1.966 on 48 degrees of freedom
## Multiple R-squared:  0.05372,    Adjusted R-squared:  0.03401 
## F-statistic: 2.725 on 1 and 48 DF,  p-value: 0.1053
## 
## 
## Call:
## lm(formula = scale(y) ~ 1 + scale(x))
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -1.6697 -0.8297  0.1675  0.6815  1.7607 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept) -1.341e-17  1.390e-01   0.000    1.000
## scale(x)    -2.318e-01  1.404e-01  -1.651    0.105
## 
## Residual standard error: 0.9828 on 48 degrees of freedom
## Multiple R-squared:  0.05372,    Adjusted R-squared:  0.03401 
## F-statistic: 2.725 on 1 and 48 DF,  p-value: 0.1053</code></pre>
</div>
<p>The CIs are not exactly identical, but very close.</p>
</div>
<div id="r-code-spearman-correlation" class="section level3">
<h3><span class="header-section-number">3.0.3</span> R code: Spearman correlation</h3>
<p>Note that we can interpret the slope which is the number of ranks <span class="math inline">\(y\)</span> change for each rank on <span class="math inline">\(x\)</span>. I think that this is a pretty interesting number. However, the intercept is less interpretable since it lies at <span class="math inline">\(rank(x) = 0\)</span> which is impossible since x starts at 1.</p>
<p>See the identical <code>r</code> (now “rho”) and <code>p</code>:</p>
<pre class="r"><code># Spearman correlation
a = cor.test(y, x, method = &quot;spearman&quot;) # Built-in
b = lm(rank(y) ~ 1 + rank(x)) # Equivalent linear model</code></pre>
Let’s look at the results: <div id="htmlwidget-18ac5bd784205e06f9a7" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-18ac5bd784205e06f9a7">{"x":{"filter":"none","data":[["cor.test","lm"],[0.1135,0.1135],[-0.2266,-0.2266]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>p.value<\/th>\n      <th>rho<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Spearman&#39;s rank correlation rho
## 
## data:  y and x
## S = 25544, p-value = 0.1135
## alternative hypothesis: true rho is not equal to 0
## sample estimates:
##        rho 
## -0.2266026 
## 
## 
## Call:
## lm(formula = rank(y) ~ 1 + rank(x))
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -26.4655 -11.5603   0.4458  11.5628  25.6921 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  31.2784     4.1191   7.593 9.11e-10 ***
## rank(x)      -0.2266     0.1406  -1.612    0.114    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 14.35 on 48 degrees of freedom
## Multiple R-squared:  0.05135,    Adjusted R-squared:  0.03159 
## F-statistic: 2.598 on 1 and 48 DF,  p-value: 0.1135</code></pre>
</div>
</div>
</div>
<div id="one-mean" class="section level1">
<h1><span class="header-section-number">4</span> One mean</h1>
<div id="t1" class="section level2">
<h2><span class="header-section-number">4.1</span> One sample t-test and Wilcoxon signed-rank</h2>
<div id="theory-as-linear-models-1" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Theory: As linear models</h3>
<p><strong>t-test</strong> model: A single number predicts <span class="math inline">\(y\)</span>.</p>
<p><span class="math inline">\(y = \beta_0 \qquad \mathcal{H}_0: \beta_0 = 0\)</span></p>
<p>In other words, it’s our good old <span class="math inline">\(y = \beta_0 + \beta_1*x\)</span> where the last term is gone since there is no <span class="math inline">\(x\)</span> (essentially <span class="math inline">\(x=0\)</span>, see left figure below).</p>
<p>The same is to a very close approximately true for <strong>Wilcoxon signed-rank test</strong>, just with the signed ranks of <span class="math inline">\(y\)</span> instead of <span class="math inline">\(y\)</span> itself (see right panel below and caveat in the end of this section):</p>
<p><span class="math inline">\(signed\_rank(y) = \beta_0\)</span></p>
<p><a href="simulate_wilcoxon.html">This approximation is good enough when the sample size is larger than 14 and almost perfect if the sample size is larger than 50</a>.</p>
<div class="fold s">
<pre class="r"><code># T-test
D_t1 = data.frame(y=rnorm_fixed(20, 0.5, 0.6),
                  x=runif(20, 0.93, 1.07))  # Fix mean and SD

P_t1 = ggplot(D_t1, aes(y=y, x=0)) + 
  stat_summary(fun.y=mean, geom = &quot;errorbar&quot;, aes(ymax = ..y.., ymin = ..y.., color=&#39;beta_0&#39;), lwd=2) +
  scale_color_manual(name=NULL, values=c(&quot;blue&quot;), labels=c(bquote(beta[0]*&quot; (intercept)&quot;))) +
  
  geom_text(aes(label=round(y, 1)), nudge_x = 0.2, size=3, color=&#39;dark gray&#39;) + 
  labs(title=&#39;         T-test&#39;)

# Wilcoxon
D_t1_rank = data.frame(y = signed_rank(D_t1$y))

P_t1_rank = ggplot(D_t1_rank, aes(y=y, x=0)) + 
  stat_summary(fun.y=mean, geom = &quot;errorbar&quot;, aes(ymax = ..y.., ymin = ..y.., color=&#39;beta_0&#39;), lwd=2) +
  scale_color_manual(name=NULL, values=c(&quot;blue&quot;), labels=c(bquote(beta[0]*&quot; (intercept)&quot;))) +

  geom_text(aes(label=y), nudge_x=0.2, size=3, color=&#39;dark gray&#39;) + 
  labs(title=&#39;         Wilcoxon&#39;)


# Stich together using patchwork
theme_axis(P_t1, ylim=c(-1, 2), legend.position=c(0.6, 0.1)) + 
  theme_axis(P_t1_rank, ylim=NULL,  legend.position=c(0.6, 0.1))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<p>One interesting implication is that <em>many “non-parametric tests” are precisely as parametric as their parametric counterparts with means, standard deviations, homogeneity of variance, etc. - just on transformed data</em>.</p>
</div>
<div id="r-code-one-sample-t-test" class="section level3">
<h3><span class="header-section-number">4.1.2</span> R code: One-sample t-test</h3>
<p>Try running the R code below and see that the linear model (<code>lm</code>) produces the same <span class="math inline">\(t\)</span>, <span class="math inline">\(p\)</span>, and <span class="math inline">\(r\)</span> as the built-in <code>t.test</code>. The confidence interval is not presented in the output of <code>lm</code> but is also identical if you use <code>confint(lm(...))</code>:</p>
<pre class="r"><code># Built-in t-test
a = t.test(y)

# Equivalent linear model: intercept-only
b = lm(y ~ 1)</code></pre>
<p>Results:</p>
<div id="htmlwidget-635d1460ab26b7a06864" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-635d1460ab26b7a06864">{"x":{"filter":"none","data":[["t.test","lm"],[0.3,0.3],[0.294,0.294],[1.0607,1.0607],[49,49],[-0.2684,-0.2684],[0.8684,0.8684]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>mean<\/th>\n      <th>p.value<\/th>\n      <th>t<\/th>\n      <th>df<\/th>\n      <th>conf.low<\/th>\n      <th>conf.high<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  One Sample t-test
## 
## data:  y
## t = 1.0607, df = 49, p-value = 0.294
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  -0.2683937  0.8683937
## sample estimates:
## mean of x 
##       0.3 
## 
## 
## Call:
## lm(formula = y ~ 1)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -3.521 -1.673  0.481  1.427  3.795 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)   0.3000     0.2828   1.061    0.294
## 
## Residual standard error: 2 on 49 degrees of freedom</code></pre>
</div>
</div>
<div id="r-code-wilcoxon-signed-rank-test" class="section level3">
<h3><span class="header-section-number">4.1.3</span> R code: Wilcoxon signed-rank test</h3>
<p>In addition to matching <code>p</code>-values, <code>lm</code> also gives us the mean signed rank, which I find to be an informative number.</p>
<pre class="r"><code># Built-in
a = wilcox.test(y)

# Equivalent linear model
b = lm(signed_rank(y) ~ 1)  # See? Same as above, just on signed ranks

# Bonus: of course also works for one-sample t-test
c = t.test(signed_rank(y))</code></pre>
<p>Results:</p>
<div id="htmlwidget-c43cb8fa604a5da8e2b7" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-c43cb8fa604a5da8e2b7">{"x":{"filter":"none","data":[["wilcox.test","lm","t.test"],[0.3693,0.3721,0.3721],[null,3.74,3.74]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>p.value<\/th>\n      <th>mean_rank<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Wilcoxon signed rank test with continuity correction
## 
## data:  y
## V = 731, p-value = 0.3693
## alternative hypothesis: true location is not equal to 0
## 
## 
## Call:
## lm(formula = signed_rank(y) ~ 1)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -49.74 -25.49   4.76  22.76  46.26 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)    3.740      4.151   0.901    0.372
## 
## Residual standard error: 29.36 on 49 degrees of freedom
## 
## 
##  One Sample t-test
## 
## data:  signed_rank(y)
## t = 0.90088, df = 49, p-value = 0.3721
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  -4.60275 12.08275
## sample estimates:
## mean of x 
##      3.74</code></pre>
</div>
</div>
</div>
<div id="tpair" class="section level2">
<h2><span class="header-section-number">4.2</span> Paired samples t-test and Wilcoxon matched pairs</h2>
<div id="theory-as-linear-models-2" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Theory: As linear models</h3>
<p><strong>t-test</strong> model: a single number (intercept) predicts the pairwise differences.</p>
<p><span class="math inline">\(y_2-y_1 = \beta_0 \qquad \mathcal{H}_0: \beta_0 = 0\)</span></p>
<p>This means that there is just one <span class="math inline">\(y = y_2 - y_1\)</span> to predict and it becomes a <a href="#t1">one-sample t-test</a> on the pairwise differences. The visualization is therefore also the same as for the one-sample t-test. At the risk of overcomplicating a simple substraction, you can think of these pairwise differences as slopes (see left panel of the figure), which we can represent as y-offsets (see right panel of the figure):</p>
<div class="fold s">
<pre class="r"><code># Data for plot
N = nrow(D_t1)
start = rnorm_fixed(N, 0.2, 0.3)
D_tpaired = data.frame(x = rep(c(0, 1), each=N), y = c(start, start + D_t1$y), id=1:N)

# Plot
P_tpaired = ggplot(D_tpaired, aes(x=x, y=y)) + 
  geom_line(aes(group=id)) + 
  labs(title=&#39;          Pairs&#39;)

# Use patchwork to put them side-by-side
theme_axis(P_tpaired) + theme_axis(P_t1, legend.position=c(0.6, 0.1))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<p>Similarly, the <strong>Wilcoxon matched pairs</strong> only differ from <strong>Wilcoxon signed-rank</strong> in that it’s testing the signed ranks of the pairwise <span class="math inline">\(y-x\)</span> differences.</p>
<p><span class="math inline">\(signed\_rank(y_2-y_1) = \beta_0 \qquad \mathcal{H}_0: \beta_0 = 0\)</span></p>
</div>
<div id="r-code-paired-sample-t-test" class="section level3">
<h3><span class="header-section-number">4.2.2</span> R code: Paired sample t-test</h3>
<pre class="r"><code>a = t.test(y, y2, paired = TRUE) # Built-in paired t-test
b = lm(y - y2 ~ 1) # Equivalent linear model</code></pre>
<p>Results:</p>
<div id="htmlwidget-77cd519bd4f19792ec4e" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-77cd519bd4f19792ec4e">{"x":{"filter":"none","data":[["t.test","lm"],[-0.2,-0.2],[0.601,0.601],[49,49],[-0.5264,-0.5264],[-0.9635,-0.9635],[0.5635,0.5635]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>mean<\/th>\n      <th>p.value<\/th>\n      <th>df<\/th>\n      <th>t<\/th>\n      <th>conf.low<\/th>\n      <th>conf.high<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Paired t-test
## 
## data:  y and y2
## t = -0.52642, df = 49, p-value = 0.601
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.9634894  0.5634894
## sample estimates:
## mean of the differences 
##                    -0.2 
## 
## 
## Call:
## lm(formula = y - y2 ~ 1)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -6.5253 -1.5642 -0.0844  1.9715  5.0361 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)  -0.2000     0.3799  -0.526    0.601
## 
## Residual standard error: 2.686 on 49 degrees of freedom</code></pre>
</div>
</div>
<div id="r-code-wilcoxon-matched-pairs" class="section level3">
<h3><span class="header-section-number">4.2.3</span> R code: Wilcoxon matched pairs</h3>
<p>Again, we do the signed-ranks trick. This is still an approximation, but a close one:</p>
<pre class="r"><code># Built-in Wilcoxon matched pairs
a = wilcox.test(y, y2, paired = TRUE)

# Equivalent linear model:
b = lm(signed_rank(y - y2) ~ 1)

# Bonus: identical to one-sample t-test ong signed ranks
c = t.test(signed_rank(y - y2))</code></pre>
<p>Results:</p>
<div id="htmlwidget-73383d6f3c53896f5ef8" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-73383d6f3c53896f5ef8">{"x":{"filter":"none","data":[["wilcox.test","lm","t.test"],[0.8243,0.8232,0.8232],[null,-0.94,-0.94]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>p.value<\/th>\n      <th>mean_rank_diff<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Wilcoxon signed rank test with continuity correction
## 
## data:  y and y2
## V = 614, p-value = 0.8243
## alternative hypothesis: true location shift is not equal to 0
## 
## 
## Call:
## lm(formula = signed_rank(y - y2) ~ 1)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -49.06 -23.81  -2.56  26.19  46.94 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)   -0.940      4.184  -0.225    0.823
## 
## Residual standard error: 29.58 on 49 degrees of freedom
## 
## 
##  One Sample t-test
## 
## data:  signed_rank(y - y2)
## t = -0.22469, df = 49, p-value = 0.8232
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  -9.347227  7.467227
## sample estimates:
## mean of x 
##     -0.94</code></pre>
</div>
<p>For large sample sizes (N &gt;&gt; 100), this approaches the <strong>sign test</strong> to a reasonable degree, but this approximation is too inaccurate to flesh out here.</p>
</div>
</div>
</div>
<div id="two-means" class="section level1">
<h1><span class="header-section-number">5</span> Two means</h1>
<div id="t2" class="section level2">
<h2><span class="header-section-number">5.1</span> Independent t-test and Mann-Whitney U</h2>
<div id="theory-as-linear-models-3" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Theory: As linear models</h3>
<p>Independent t-test model: two means predict <span class="math inline">\(y\)</span>.</p>
<p><span class="math inline">\(y_i = \beta_0 + \beta_1 x_i \qquad \mathcal{H}_0: \beta_1 = 0\)</span></p>
<p>where <span class="math inline">\(x_i\)</span> is an indicator (0 or 1) saying whether data point <span class="math inline">\(i\)</span> was sampled from one or the other group. <a href="https://en.wikipedia.org/wiki/Dummy_variable_(statistics)">Indicator variables (also called “dummy coding”)</a> underly a lot of linear models and we’ll take an aside to see how it works in a minute.</p>
<p><strong>Mann-Whitney U</strong> (also known as <strong>Wilcoxon signed-rank test</strong> for two independent groups) is the same model to a very close approximation, just on the ranks of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> instead of the actual values:</p>
<p><span class="math inline">\(rank(y_i) = \beta_0 + \beta_1 x_i \qquad \mathcal{H}_0: \beta_1 = 0\)</span></p>
<p>To me, equivalences like this make “non-parametric” statistics much easier to understand. The approximation is appropriate <a href="simulate_mannwhitney.html">when the sample size is larger than 11 in each group and virtually perfect when N &gt; 30 in each group</a>.</p>
</div>
<div id="dummy" class="section level3">
<h3><span class="header-section-number">5.1.2</span> Theory: Dummy coding</h3>
<p>Dummy coding can be understood visually. The indicator is on the x-axis so data points from the first group are located at <span class="math inline">\(x = 0\)</span> and data points from the second group is located at <span class="math inline">\(x = 1\)</span>. Then <span class="math inline">\(\beta_0\)</span> is the intercept (red line) and <span class="math inline">\(\beta_1\)</span> is the slope between the two means (green line). Why? Because when <span class="math inline">\(\Delta x = 1\)</span> the slope equals the difference because:</p>
<p><span class="math inline">\(slope = \Delta y / \Delta x = \Delta y / 1 = \Delta y = difference\)</span></p>
<p>Magic! Even categorical differences can be modelled using linear models! It’s a true Swizz army knife.</p>
<div class="fold s">
<pre class="r"><code># Data
N = 20  # Number of data points per group
D_t2 = data.frame(
  x = rep(c(0, 1), each=N),
  y = c(rnorm_fixed(N, 0.3, 0.3), rnorm_fixed(N, 1.3, 0.3))
)

# Plot
P_t2 = ggplot(D_t2, aes(x=x, y=y)) + 
  stat_summary(fun.y=mean, geom = &quot;errorbar&quot;, aes(ymax = ..y.., ymin = ..y.., color=&#39;something&#39;), lwd=2) +
  geom_segment(x=-10, xend=10, y=0.3, yend=0.3, lwd=2, aes(color=&#39;beta_0&#39;)) + 
  geom_segment(x=0, xend=1, y=0.3, yend=1.3, lwd=2, aes(color=&#39;beta_1&#39;)) + 
  
  scale_color_manual(name=NULL, values=c(&quot;blue&quot;, &quot;red&quot;, &quot;darkblue&quot;), labels=c(bquote(beta[0]*&quot; (group 1 mean)&quot;), bquote(beta[1]*&quot; (slope = difference)&quot;), bquote(beta[0]+beta[1]%.%1*&quot; (group 2 mean)&quot;)))
  #scale_x_discrete(breaks=c(0.5, 1.5), labels=c(&#39;1&#39;, &#39;2&#39;))

theme_axis(P_t2, jitter=TRUE, xlim=c(-0.3, 2), legend.position=c(0.53, 0.08))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-26-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="dummy2" class="section level3">
<h3><span class="header-section-number">5.1.3</span> Theory: Dummy coding (continued)</h3>
<p>If you feel like you get dummy coding now, just skip ahead to the next section. Here is a more elaborate explanation of dummy coding:</p>
<p>If a data point was sampled from the first group, i.e., when <span class="math inline">\(x_i = 0\)</span>, the model simply becomes <span class="math inline">\(y = \beta_0 + \beta_1 \cdot 0 = \beta_0\)</span>. In other words, the model predicts that that data point is <span class="math inline">\(beta_0\)</span>. It turns out that the <span class="math inline">\(\beta\)</span> which best predicts a set of data points is the <em>mean</em> of those data points, so <span class="math inline">\(\beta_0\)</span> is the mean of group 1.</p>
<p>On the other hand, data points sampled from the second group would have <span class="math inline">\(x_i = 1\)</span> so the model becomes <span class="math inline">\(y_i = \beta_0 + \beta_1\cdot 1 = \beta_0 + \beta_1\)</span>. In other words, we add <span class="math inline">\(\beta_1\)</span> to “shift” from the mean of the first group to the mean of the second group. Thus <span class="math inline">\(\beta_1\)</span> becomes the <em>mean difference</em> between the groups.</p>
<p>As an example, say group 1 is 25 years old (<span class="math inline">\(\beta_0 = 25\)</span>) and group 2 is 28 years old (<span class="math inline">\(\beta_1 = 3\)</span>), then the model for a person in group 1 is <span class="math inline">\(y = 25 + 3 \cdot 0 = 25\)</span> and the model for a person in group 2 is <span class="math inline">\(y = 25 + 3 \cdot 1 = 28\)</span>.</p>
<p>Hooray, it works! For first-timers it takes a few moments to understand dummy coding, but you only need to know addition and multiplication to get there!</p>
</div>
<div id="r-code-independent-t-test" class="section level3">
<h3><span class="header-section-number">5.1.4</span> R code: independent t-test</h3>
<p>As a reminder, when we write <code>y ~ 1 + x</code> in R, it is shorthand for <span class="math inline">\(y = \beta_0 \cdot 1 + \beta_1 \cdot x\)</span> and R goes on computing the <span class="math inline">\(\beta\)</span>s for you. Thus <code>y ~ 1 + x</code> is the R-way of writing <span class="math inline">\(y = a \cdot x + b\)</span>.</p>
<p>Notice the identical <code>t</code>, <code>df</code>, <code>p</code>, and estimates. We can get the confidence interval by running <code>confint(lm(...))</code>.</p>
<pre class="r"><code># Built-in independent t-test on wide data
a = t.test(y, y2, var.equal = TRUE)

# Be explicit about the underlying linear model by hand-dummy-coding:
group_y2 = ifelse(group == &#39;y2&#39;, 1, 0)  # 1 if group == y2, 0 otherwise
b = lm(value ~ 1 + group_y2)  # Using our hand-made dummy regressor

# Note: We could also do the dummy-coding in the model 
# specification itself. Same result.
c = lm(value ~ 1 + I(group==&#39;y2&#39;))</code></pre>
<p>Results:</p>
<div id="htmlwidget-53b434c497272bb7da0e" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-53b434c497272bb7da0e">{"x":{"filter":"none","data":[["t.test","lm"],[0.3,0.3],[0.2,0.2],[0.5729,0.5729],[98,98],[-0.5016,-0.5016],[0.9016,0.9016]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>mean_y<\/th>\n      <th>difference<\/th>\n      <th>p.value<\/th>\n      <th>df<\/th>\n      <th>conf.low<\/th>\n      <th>conf.high<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Two Sample t-test
## 
## data:  y and y2
## t = -0.56569, df = 98, p-value = 0.5729
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.9016152  0.5016152
## sample estimates:
## mean of x mean of y 
##       0.3       0.5 
## 
## 
## Call:
## lm(formula = value ~ 1 + group_y2)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.5211 -1.1259 -0.2124  0.9151  4.9268 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)   0.3000     0.2500   1.200    0.233
## group_y2      0.2000     0.3536   0.566    0.573
## 
## Residual standard error: 1.768 on 98 degrees of freedom
## Multiple R-squared:  0.003255,   Adjusted R-squared:  -0.006916 
## F-statistic:  0.32 on 1 and 98 DF,  p-value: 0.5729
## 
## 
## Call:
## lm(formula = value ~ 1 + I(group == &quot;y2&quot;))
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -3.5211 -1.1259 -0.2124  0.9151  4.9268 
## 
## Coefficients:
##                      Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)            0.3000     0.2500   1.200    0.233
## I(group == &quot;y2&quot;)TRUE   0.2000     0.3536   0.566    0.573
## 
## Residual standard error: 1.768 on 98 degrees of freedom
## Multiple R-squared:  0.003255,   Adjusted R-squared:  -0.006916 
## F-statistic:  0.32 on 1 and 98 DF,  p-value: 0.5729</code></pre>
</div>
</div>
<div id="r-code-mann-whitney-u" class="section level3">
<h3><span class="header-section-number">5.1.5</span> R code: Mann-Whitney U</h3>
<pre class="r"><code># Wilcoxon / Mann-Whitney U
a = wilcox.test(y, y2)

# As linear model with our dummy-coded group_y2:
b = lm(rank(value) ~ 1 + group_y2)  # compare to linear model above</code></pre>
<div id="htmlwidget-0b05f5a4b604340b9f1a" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-0b05f5a4b604340b9f1a">{"x":{"filter":"none","data":[["wilcox.test","lm"],[0.7907,0.7896],[null,1.56]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>p.value<\/th>\n      <th>rank_diff<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Wilcoxon rank sum test with continuity correction
## 
## data:  y and y2
## W = 1211, p-value = 0.7907
## alternative hypothesis: true location shift is not equal to 0
## 
## 
## Call:
## lm(formula = rank(value) ~ 1 + group_y2)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -48.72 -24.64  -0.78  24.22  48.72 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)   49.720      4.122  12.061   &lt;2e-16 ***
## group_y2       1.560      5.830   0.268     0.79    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 29.15 on 98 degrees of freedom
## Multiple R-squared:  0.0007302,  Adjusted R-squared:  -0.009466 
## F-statistic: 0.07161 on 1 and 98 DF,  p-value: 0.7896</code></pre>
</div>
</div>
</div>
<div id="welch" class="section level2">
<h2><span class="header-section-number">5.2</span> Welch’s t-test</h2>
<p>This is identical to the (Student’s) <a href="#t2">independent t-test</a> above except that Student’s assumes identical variances and <strong>Welch’s t-test</strong> does not. So the linear model is the same and the trick is in the variances, which I won’t go further into here.</p>
<pre class="r"><code># Built-in
a = t.test(y, y2, var.equal=FALSE)

# As linear model with per-group variances
b = nlme::gls(value ~ 1 + group_y2, weights = nlme::varIdent(form=~1|group), method=&quot;ML&quot;)</code></pre>
<p>Results:</p>
<div id="htmlwidget-accd39a4468ae76de8c1" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-accd39a4468ae76de8c1">{"x":{"filter":"none","data":[["t.test","gls"],[0.3,0.3],[0.2,0.2],[0.573,0.5729],[-0.5657,-0.5657],[-0.9023,-0.893],[0.5023,0.493]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>mean_y<\/th>\n      <th>mean_diff<\/th>\n      <th>p.value<\/th>\n      <th>t<\/th>\n      <th>conf.low<\/th>\n      <th>conf.high<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  y and y2
## t = -0.56569, df = 90.875, p-value = 0.573
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.9023034  0.5023034
## sample estimates:
## mean of x mean of y 
##       0.3       0.5 
## 
## Generalized least squares fit by maximum likelihood
##   Model: value ~ 1 + group_y2 
##   Data: NULL 
##        AIC      BIC    logLik
##   399.6287 410.0493 -195.8143
## 
## Variance function:
##  Structure: Different standard deviations per stratum
##  Formula: ~1 | group 
##  Parameter estimates:
##   y1   y2 
## 1.00 0.75 
## 
## Coefficients:
##             Value Std.Error   t-value p-value
## (Intercept)   0.3 0.2828427 1.0606602  0.2915
## group_y2      0.2 0.3535534 0.5656854  0.5729
## 
##  Correlation: 
##          (Intr)
## group_y2 -0.8  
## 
## Standardized residuals:
##        Min         Q1        Med         Q3        Max 
## -1.7784113 -0.7177541 -0.1430665  0.5635189  3.3178730 
## 
## Residual standard error: 1.979899 
## Degrees of freedom: 100 total; 98 residual</code></pre>
</div>
</div>
</div>
<div id="three-or-more-means" class="section level1">
<h1><span class="header-section-number">6</span> Three or more means</h1>
<p>ANOVAs are linear models with (only) categorical predictors so they simply extend everything we did above, relying heavily on dummy coding. Do make sure to read <a href="#dummy">the section on dummy coding</a> if you haven’t already.</p>
<div id="anova1" class="section level2">
<h2><span class="header-section-number">6.1</span> One-way ANOVA and Kruskal-Wallis</h2>
<div id="theory-as-linear-models-4" class="section level3">
<h3><span class="header-section-number">6.1.1</span> Theory: As linear models</h3>
<p>Model: One mean for each group predicts <span class="math inline">\(y\)</span>.</p>
<p><span class="math inline">\(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_3 +... \qquad \mathcal{H}_0: y = \beta_1\)</span></p>
<p>where <span class="math inline">\(x_i\)</span> are indicators (<span class="math inline">\(x=0\)</span> or <span class="math inline">\(x=1\)</span>) where at most one <span class="math inline">\(x_i=1\)</span> while all others are <span class="math inline">\(x_i=0\)</span>.</p>
<p>Notice how this is just “more of the same” of what we already did in other models above. When there are only two groups, this model is <span class="math inline">\(y = \beta_0 + \beta_1*x\)</span>, i.e. the <a href="#t2">independent t-test</a>. If there is only one group, it is <span class="math inline">\(y = \beta_0\)</span>, i.e. the <a href="#t1">one-sample t-test</a>. This is easy to see in the visualization below - just cover up a few groups and see that it matches the other visualizations above, though I did omit adding green lines from the intercept (red) to the group means (blue) for visual clarity.</p>
<div class="fold s">
<pre class="r"><code># Figure
N = 15
D_anova1 = data.frame(
  y=c(rnorm_fixed(N, 0.5, 0.3), 
      rnorm_fixed(N, 0, 0.3), 
      rnorm_fixed(N, 1, 0.3), 
      rnorm_fixed(N, 0.8, 0.3)), 
  x=rep(0:3, each=15)
)
ymeans = aggregate(y~x, D_anova1, mean)$y
P_anova1 = ggplot(D_anova1, aes(x=x, y=y)) + 
  stat_summary(fun.y=mean, geom = &quot;errorbar&quot;, aes(ymax = ..y.., ymin = ..y.., color=&#39;intercepts&#39;), lwd=2) + 
  geom_segment(x=-10, xend=100, y=0.5, yend=0.5, lwd=2, aes(color=&#39;beta_0&#39;)) +
  geom_segment(x=0, xend=1, y=ymeans[1], yend=ymeans[2], lwd=2, aes(color=&#39;betas&#39;)) +
  geom_segment(x=1, xend=2, y=ymeans[1], yend=ymeans[3], lwd=2, aes(color=&#39;betas&#39;)) +
  geom_segment(x=2, xend=3, y=ymeans[1], yend=ymeans[4], lwd=2, aes(color=&#39;betas&#39;)) +
  
  scale_color_manual(
    name=NULL, values=c(&quot;blue&quot;, &quot;red&quot;, &quot;darkblue&quot;), 
    labels=c(
      bquote(beta[0]*&quot; (group 1 mean)&quot;), 
      bquote(beta[1]*&quot;, &quot;*beta[2]*&quot;,  etc. (slopes/differences to &quot;*beta[0]*&quot;)&quot;),
      bquote(beta[0]*&quot;+&quot;*beta[1]*&quot;, &quot;*beta[0]*&quot;+&quot;*beta[2]*&quot;, etc. (absolute intercepts)&quot;)
    )
  )
  

theme_axis(P_anova1, xlim=c(-0.5, 4), legend.position=c(0.7, 0.1))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-36-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<p>A one-way ANOVA has a log-linear counterpart called <a href="#goodness">goodness-of-fit</a> test which we’ll return to. By the way, since we now regress on more than one <span class="math inline">\(x\)</span>, the one-way ANOVA is a <strong>multiple regression</strong> model.</p>
<p>The <strong>Kruskal-Wallis</strong> test is simply a <strong>one-way ANOVA</strong> on the rank-transformed <span class="math inline">\(y\)</span> (<code>value</code>):</p>
<p><span class="math inline">\(rank(y) = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_3 +...\)</span></p>
<p>This approximation is <a href="simulate_kruskall.html">good enough for 12 or more data points</a>. Again, if you do this for just one or two groups, we’re already acquainted with those equations, i.e. the <a href="#t1">Wilcoxon signed-rank test</a> or the <a href="#t2">Mann-Whitney U test</a> respectively.</p>
</div>
<div id="example-data" class="section level3">
<h3><span class="header-section-number">6.1.2</span> Example data</h3>
<p>We make a three-level factor with the levels <code>a</code>, <code>b</code>, and <code>c</code> so that the <strong>one-way ANOVA</strong> basically becomes a “three-sample t-test”. Then we manually do the <a href="#dummy">dummy coding</a> of the groups.</p>
<pre class="r"><code># Three variables in &quot;long&quot; format
N = 20  # Number of samples per group
D = data.frame(
   value = c(rnorm_fixed(N, 0), rnorm_fixed(N, 1), rnorm_fixed(N, 0.5)), 
   group = rep(c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), each=N),
   
   # Explicitly add indicator/dummy variables
   # Could also be done using model.matrix(~D$group)
   group_a = rep(c(1, 0, 0), each=N),
   group_b = rep(c(0, 1, 0), each=N),
   group_c = rep(c(0, 0, 1), each=N))  # N of each level</code></pre>
<div id="htmlwidget-70a39cca644e058980b8" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-70a39cca644e058980b8">{"x":{"filter":"none","data":[[1.2054,-0.3238,-2.2574,-0.3088,0.8638,0.9145,1.2604,-0.4439,-0.6537,-0.6647,0.3751,1.0547,-0.4506,-0.2959,-0.0689,0.67,-1.1847,1.4327,0.4198,-1.5439,1.3094,2.488,0.7133,0.361,0.902,2.3742,-0.0172,0.2945,2.2848,-0.1022,0.2534,1.7632,0.7837,1.8609,-0.4687,-0.1086,0.6003,2.4223,2.2305,0.0551,0.8815,0.5242,0.8554,0.3194,0.1591,0.0174,0.0715,2.0275,1.7328,-0.7752,0.6351,0.0606,0.0999,1.2877,0.4873,-0.7995,-1.9402,2.3574,0.7758,1.2222],["a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c"],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>value<\/th>\n      <th>group<\/th>\n      <th>group_a<\/th>\n      <th>group_b<\/th>\n      <th>group_c<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":true,"bInfo":true,"paging":true,"columnDefs":[{"className":"dt-right","targets":[0,2,3,4]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<p>See? Exactly one parameter predicts a <code>value</code> in a given row while the others are not included in the modeling of that <code>value</code>.</p>
</div>
<div id="r-code-one-way-anova" class="section level3">
<h3><span class="header-section-number">6.1.3</span> R code: one-way ANOVA</h3>
<p>OK, let’s see the identity between the built-in <strong>ANOVA</strong> (<code>car::Anova</code>) and the in-your-face linear model, <code>lm</code>. The latter returns parameter estimates as well, but look at the overall model F-statistics which are identical. Note that I do not use the <code>aov</code> function because it computes type-I sum of squares. There is a BIG polarized debate about whether to use type-II (as <code>car::Anova</code> does by default) or type-III sum of squares, but let’s skip that for now.</p>
<pre class="r"><code># Compare built-in and linear model
a = car::Anova(aov(value ~ group, D))  # Built-in ANOVA
b = lm(value ~ 1 + group_a + group_b + group_c, data=D)  # As in-your-face linear model</code></pre>
<p>Results:</p>
<div id="htmlwidget-1ab0d000b26193e8df53" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-1ab0d000b26193e8df53">{"x":{"filter":"none","data":[["Anova","lm"],[5,5],[0.01,0.01],[2,3],[57,57]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>F<\/th>\n      <th>p.value<\/th>\n      <th>df<\/th>\n      <th>df.residual<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## Anova Table (Type II tests)
## 
## Response: value
##           Sum Sq Df F value   Pr(&gt;F)   
## group         10  2       5 0.009984 **
## Residuals     57 57                    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Call:
## lm(formula = value ~ 1 + group_a + group_b + group_c, data = D)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -2.4402 -0.6427 -0.1393  0.8060  1.8574 
## 
## Coefficients: (1 not defined because of singularities)
##             Estimate Std. Error t value Pr(&gt;|t|)  
## (Intercept)   0.5000     0.2236   2.236   0.0293 *
## group_a      -0.5000     0.3162  -1.581   0.1194  
## group_b       0.5000     0.3162   1.581   0.1194  
## group_c           NA         NA      NA       NA  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1 on 57 degrees of freedom
## Multiple R-squared:  0.1493, Adjusted R-squared:  0.1194 
## F-statistic:     5 on 2 and 57 DF,  p-value: 0.009984</code></pre>
</div>
</div>
<div id="r-code-kruskal-wallis" class="section level3">
<h3><span class="header-section-number">6.1.4</span> R code: Kruskal-Wallis</h3>
<pre class="r"><code>a = kruskal.test(value ~ group, D)  # Built-in
b = lm(rank(value) ~ 1 + group_a + group_b + group_c, D)  # As linear model
c = car::Anova(aov(rank(value) ~ group, D))  # Of course the same using the built-in ANOVA, which is just a wrapper around lm</code></pre>
<p>Results:</p>
<div id="htmlwidget-17f92ca3804c39b73546" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-17f92ca3804c39b73546">{"x":{"filter":"none","data":[["kruskal.test","lm"],[0.0355,0.0326]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>p.value<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":1}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Kruskal-Wallis rank sum test
## 
## data:  value by group
## Kruskal-Wallis chi-squared = 6.6777, df = 2, p-value = 0.03548
## 
## 
## Call:
## lm(formula = rank(value) ~ 1 + group_a + group_b + group_c, data = D)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -28.950 -12.213  -0.675  15.912  26.850 
## 
## Coefficients: (1 not defined because of singularities)
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)   30.950      3.741   8.272 2.43e-11 ***
## group_a       -7.800      5.291  -1.474    0.146    
## group_b        6.450      5.291   1.219    0.228    
## group_c           NA         NA      NA       NA    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 16.73 on 57 degrees of freedom
## Multiple R-squared:  0.1132, Adjusted R-squared:  0.08206 
## F-statistic: 3.637 on 2 and 57 DF,  p-value: 0.03261
## 
## Anova Table (Type II tests)
## 
## Response: rank(value)
##            Sum Sq Df F value  Pr(&gt;F)  
## group      2036.7  2  3.6374 0.03261 *
## Residuals 15958.3 57                  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
</div>
</div>
<div id="anova2" class="section level2">
<h2><span class="header-section-number">6.2</span> Two-way ANOVA (plot in progress!)</h2>
<div id="theory-as-linear-models-5" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Theory: As linear models</h3>
<p>Model: one mean per group (main effects) plus these means multiplied across factors (interaction effects). The main effects are the <a href="#anova1">one-way ANOVA</a>s above, though in the context of a larger model. The interaction effect is harder to explain in the abstract even though it’s just a few numbers multiplied with each other. I will leave that to the teachers to keep focus on equivalences here :-)</p>
<p>Switching to matrix notation:</p>
<p><span class="math inline">\(y = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_1 X_2 \qquad \mathcal{H}_0: \beta_3 = 0\)</span></p>
<p>Here <span class="math inline">\(\beta_i\)</span> are vectors of betas of which only one is selected by the indicator vector <span class="math inline">\(X_i\)</span>. The <span class="math inline">\(\mathcal{H}_0\)</span> shown here is the interaction effect. Note that the intercept <span class="math inline">\(\beta_0\)</span>, to which all other <span class="math inline">\(\beta\)</span>s are relative, is now the mean for the first level of all factors.</p>
<p>Continuing with the dataset from the one-way ANOVA above, let’s add a crossing factor <code>mood</code> so that we can test the <code>group:mood</code> interaction (a 3x2 ANOVA). We also do the <a href="#dummy">dummy coding</a> of this factor needed for the linear model.</p>
<pre class="r"><code># Crossing factor
D$mood = c(&#39;happy&#39;, &#39;sad&#39;)

# Dummy coding
D$mood_happy = ifelse(D$mood == &#39;happy&#39;, 1, 0)  # 1 if mood==happy. 0 otherwise.
D$mood_sad = ifelse(D$mood == &#39;sad&#39;, 1, 0)  # Same, but we won&#39;t be needing this</code></pre>
<div id="htmlwidget-f1358fffeb3bd1d82ace" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-f1358fffeb3bd1d82ace">{"x":{"filter":"none","data":[[1.2054,-0.3238,-2.2574,-0.3088,0.8638,0.9145,1.2604,-0.4439,-0.6537,-0.6647,0.3751,1.0547,-0.4506,-0.2959,-0.0689,0.67,-1.1847,1.4327,0.4198,-1.5439,1.3094,2.488,0.7133,0.361,0.902,2.3742,-0.0172,0.2945,2.2848,-0.1022,0.2534,1.7632,0.7837,1.8609,-0.4687,-0.1086,0.6003,2.4223,2.2305,0.0551,0.8815,0.5242,0.8554,0.3194,0.1591,0.0174,0.0715,2.0275,1.7328,-0.7752,0.6351,0.0606,0.0999,1.2877,0.4873,-0.7995,-1.9402,2.3574,0.7758,1.2222],["a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c","c"],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],["happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad","happy","sad"],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>value<\/th>\n      <th>group<\/th>\n      <th>group_a<\/th>\n      <th>group_b<\/th>\n      <th>group_c<\/th>\n      <th>mood<\/th>\n      <th>mood_happy<\/th>\n      <th>mood_sad<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":true,"bInfo":true,"paging":true,"columnDefs":[{"className":"dt-right","targets":[0,2,3,4,6,7]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<p><span class="math inline">\(\beta_0\)</span> is now the happy guys from group a!</p>
<div class="fold s">
<pre class="r"><code># Add intercept line
# Add cross...
# Use other data?

means = lm(value ~ mood * group, D)$coefficients

P_anova2 = ggplot(D, aes(x=group, y=value, color=mood)) + 
  geom_segment(x=-10, xend=100, y=means[1], yend=0.5, col=&#39;blue&#39;, lwd=2) +
  stat_summary(fun.y=mean, geom = &quot;errorbar&quot;, aes(ymax = ..y.., ymin = ..y..),  lwd=2)
theme_axis(P_anova2, xlim=c(-0.5, 3.5)) + theme(axis.text.x = element_text())</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-47-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="r-code-two-way-anova" class="section level3">
<h3><span class="header-section-number">6.2.2</span> R code: Two-way ANOVA</h3>
<p>Now let’s turn to the actual modeling in R. We compare the built-in ANOVA function to the linear model using <code>lm</code>. Notice that in ANOVA, we are testing a full factor interaction all at once which involves many parameters (two in this case), so we can’t look at the overall model fit nor any particular parameter for the result. Therefore, I use a likelihood-ratio test to compare a full two-way ANOVA model (“saturated”) to one without the interaction effect(s). We do so using the <code>anova</code> function. Even though that looks like cheating, it’s just computing likelihoods, p-values, etc. on the models that were already fitted, so it’s legit!</p>
<pre class="r"><code># Built-in two-way ANOVA.
a = car::Anova(aov(value ~ mood * group, D), type=&#39;II&#39;)  # Normal notation. &quot;*&quot; both multiplies and adds main effects
b = car::Anova(aov(value ~ mood + group + mood:group, D))  # Identical but more verbose about main effects and interaction

# Testing the interaction terms as linear model.
full = lm(value ~ 1 + group_a + group_b + mood_happy + group_a:mood_happy + group_b:mood_happy, D)  # Full model
null = lm(value ~ 1 + group_a + group_b + mood_happy, D)  # Without interaction
c = anova(null, full)  # whoop whoop, same F, p, and Dfs</code></pre>
<p>Results:</p>
<div id="htmlwidget-87bf6d89bc45e0caea1f" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-87bf6d89bc45e0caea1f">{"x":{"filter":"none","data":[["Anova mood:group","lm LRT"],[0.0459,0.0459],[2,2],[0.9552,0.9552],[0.0956,0.0956],[56.2468,56.2468]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>F<\/th>\n      <th>df<\/th>\n      <th>p.value<\/th>\n      <th>sumsq<\/th>\n      <th>res.sumsq<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## Anova Table (Type II tests)
## 
## Response: value
##            Sum Sq Df F value  Pr(&gt;F)  
## mood        0.658  1  0.6314 0.43032  
## group      10.000  2  4.8003 0.01206 *
## mood:group  0.096  2  0.0459 0.95520  
## Residuals  56.247 54                  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Analysis of Variance Table
## 
## Model 1: value ~ 1 + group_a + group_b + mood_happy
## Model 2: value ~ 1 + group_a + group_b + mood_happy + group_a:mood_happy + 
##     group_b:mood_happy
##   Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)
## 1     56 56.342                           
## 2     54 56.247  2  0.095565 0.0459 0.9552</code></pre>
</div>
<p>Below, I present approximate main effect models, though exact calculation of ANOVA main effects <a href="https://stats.idre.ucla.edu/stata/faq/how-can-i-get-anova-simple-main-effects-with-dummy-coding/">is more involved</a> if it is to be accurate and furthermore depend on whether type-II or type-III sum of squares are used for inference.</p>
<p>Look at the model summary statistics to find values comparable to the <code>Anova</code>-estimated main effects above.</p>
<pre class="r"><code># Main effect of group.
e = lm(value ~ 1 + group_a + group_b, D)

# Main effect of mood.
f = lm(value ~ 1 + mood_happy, D)</code></pre>
<div id="htmlwidget-ec5b7c1d5b020167d8ef" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-ec5b7c1d5b020167d8ef">{"x":{"filter":"none","data":[["group","group","mood","mood"],["Anova","lm","Anova","lm"],[4.8003,5,0.6314,0.575],[0.0121,0.01,0.4303,0.4514]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>term<\/th>\n      <th>model<\/th>\n      <th>F<\/th>\n      <th>p.value<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[2,3]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
## Call:
## lm(formula = value ~ 1 + group_a + group_b, data = D)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -2.4402 -0.6427 -0.1393  0.8060  1.8574 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)  
## (Intercept)   0.5000     0.2236   2.236   0.0293 *
## group_a      -0.5000     0.3162  -1.581   0.1194  
## group_b       0.5000     0.3162   1.581   0.1194  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1 on 57 degrees of freedom
## Multiple R-squared:  0.1493, Adjusted R-squared:  0.1194 
## F-statistic:     5 on 2 and 57 DF,  p-value: 0.009984
## 
## 
## Call:
## lm(formula = value ~ 1 + mood_happy, data = D)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -2.65275 -0.70847  0.00213  0.63391  1.88950 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)   
## (Intercept)   0.6047     0.1953   3.097  0.00301 **
## mood_happy   -0.2094     0.2761  -0.758  0.45136   
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.07 on 58 degrees of freedom
## Multiple R-squared:  0.009816,   Adjusted R-squared:  -0.007256 
## F-statistic: 0.575 on 1 and 58 DF,  p-value: 0.4514</code></pre>
</div>
</div>
</div>
<div id="ancova" class="section level2">
<h2><span class="header-section-number">6.3</span> ANCOVA</h2>
<p>This is simply ANOVA with a continuous regressor added so that it now contains continuous and (dummy-coded) categorical predictors. For example, if we continue with the <a href="#anova1">one-way ANOVA</a> example, we can add <code>age</code> and it is now called a <strong>one-way ANCOVA</strong>:</p>
<p><span class="math inline">\(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + ... + \beta_3 age\)</span></p>
<p>… where <span class="math inline">\(x_i\)</span> are our usual dummy-coded indicator variables. <span class="math inline">\(\beta_0\)</span> is now the mean for the first group at <span class="math inline">\(age=0\)</span>. You can turn all ANOVAs into ANCOVAs this way, e.g. by adding <span class="math inline">\(\beta_N \cdot age\)</span> to our <strong>two-way ANOVA</strong> in the previous section. But let us go ahead with our one-way ANCOVA, starting by adding <span class="math inline">\(age\)</span> to our dataset:</p>
<pre class="r"><code># Update data with a continuous covariate
D$age = D$value + rnorm_fixed(nrow(D), sd=3)  # Correlated to value</code></pre>
<p>This is best visualized using colors for groups instead of x-position. The <span class="math inline">\(\beta\)</span>s are still the average <span class="math inline">\(y\)</span>-offset of the data points, only now we model each group using a slope instead of an intercept. In other words, the one-way ANOVA is sort of <a href="#t1">one-sample t-tests</a> model for each group (<span class="math inline">\(y = \beta_0\)</span>) while the <strong>one-way ANCOVA</strong> is sort of <a href="#correlation">Pearson correlation</a> model for each group (<span class="math inline">\(y_i = \beta_0 + \beta_i + \beta_1 \cdot age\)</span>):</p>
<div class="fold s">
<pre class="r"><code># For linear model plot
D$pred = predict(lm(value ~ age + group, D))

# Plot
P_ancova = ggplot(D, aes(x=age, y=value, color=group, shape=group)) + 
  geom_line(aes(y=pred), lwd=2)

# Theme it
theme_axis(P_ancova, xlim=NULL, ylim=NULL, legend.position=c(0.8, 0.2)) + theme(axis.title=element_text())</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-55-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<p>And now some R code to run the one-way ANCOVA as a linear model:</p>
<pre class="r"><code># Built-in ANCOVA. The order of factors matter in pure-aov (type-I variance).
# Use type-II or type-III instead; implemented in car::Anova
a = car::Anova(aov(value ~ group + age, D))
#a = aov(value ~ group + age, D)  # Predictor order matters. Not nice!

# As dummy-coded linear model. 
full = lm(value ~ 1 + group_a + group_b + age, D)

# Testing main effect of age using Likelihood-ratio test
null_age = lm(value ~ 1 + group_a + group_b, D)  # Full without age. One-way ANOVA!
result_age = anova(null_age, full)

# Testing main effect of groupusing Likelihood-ratio test
null_group = lm(value ~ 1 + age, D)  # Full without group. Pearson correlation!
result_group = anova(null_group, full)</code></pre>
<p>Results:</p>
<div id="htmlwidget-d6d6501cf4c5f1a37217" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-d6d6501cf4c5f1a37217">{"x":{"filter":"none","data":[["age","age","group","group"],["Anova","lm","Anova","lm"],[16.3967,16.3967,6.4258,6.4258],[1,1,2,2],[0.0002,0.0002,0.0031,0.0031],[12.9096,12.9096,10.1184,10.1184],[44.0904,44.0904,44.0904,44.0904],[56,56,56,56]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>term<\/th>\n      <th>model<\/th>\n      <th>F<\/th>\n      <th>df<\/th>\n      <th>p.value<\/th>\n      <th>sumsq<\/th>\n      <th>res.sumsq<\/th>\n      <th>res.df<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5,6,7]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## Anova Table (Type II tests)
## 
## Response: value
##           Sum Sq Df F value    Pr(&gt;F)    
## group     10.118  2  6.4258 0.0030738 ** 
## age       12.910  1 16.3967 0.0001595 ***
## Residuals 44.090 56                      
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Analysis of Variance Table
## 
## Model 1: value ~ 1 + group_a + group_b
## Model 2: value ~ 1 + group_a + group_b + age
##   Res.Df   RSS Df Sum of Sq      F    Pr(&gt;F)    
## 1     57 57.00                                  
## 2     56 44.09  1     12.91 16.397 0.0001595 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Analysis of Variance Table
## 
## Model 1: value ~ 1 + age
## Model 2: value ~ 1 + group_a + group_b + age
##   Res.Df    RSS Df Sum of Sq      F   Pr(&gt;F)   
## 1     58 54.209                                
## 2     56 44.090  2    10.118 6.4258 0.003074 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<!--
Is there a well-known "non-parametric" ANCOVA? No, but now that we understand it as a mix of a **Pearson correlation** and **t-tests**, you can get creative and make one up. If we rank the $y$ and the $x$ we get a **Spearman correlation** ($rank(y) ~ \beta_0 + rank(x)$) and at the same time the **Wilcoxon** ($rank(y) ~ 1):

$rank(y) = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + ... + \beta_3 rank(age)$

As I noted earlier, this does not match up perfectly with the true "non-parametric" model (if that exists), but it can be very close!


```r
full = lm(rank(value) ~ group + rank(age), D)
null = lm(rank(value) ~ rank(age), D)
anova(null, full)
```

```
## Analysis of Variance Table
## 
## Model 1: rank(value) ~ rank(age)
## Model 2: rank(value) ~ group + rank(age)
##   Res.Df   RSS Df Sum of Sq      F  Pr(>F)  
## 1     58 14870                              
## 2     56 12768  2    2102.3 4.6105 0.01401 *
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

```r
sm::sm.ancova(x=D$age, y=D$value, group=D$group, display='none', model='equal')
```

```
## Test of equality :  h =  1.08418    p-value =  0.3322
```
-->
</div>
</div>
<div id="proportions-chi-square-is-a-log-linear-model" class="section level1">
<h1><span class="header-section-number">7</span> Proportions: Chi-square is a log-linear model</h1>
<p>Recall that when you take the logarithm, you can easily make statements about <em>proportions</em>, i.e., that for every increase in <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> increases a certain percentage. This turns out to be one of the simplest (and therefore best!) ways to make count data and contingency tables intelligible. See <a href="https://www.uni-tuebingen.de/fileadmin/Uni_Tuebingen/SFB/SFB_833/A_Bereich/A1/Christoph_Scheepers_-_Statistikworkshop.pdf">this nice introduction</a> to Chi-Square tests as linear models.</p>
<div id="goodness" class="section level2">
<h2><span class="header-section-number">7.1</span> Goodness of fit</h2>
<div id="theory-as-log-linear-model" class="section level3">
<h3><span class="header-section-number">7.1.1</span> Theory: As log-linear model</h3>
<p>Model: a single intercept predicts <span class="math inline">\(log(y)\)</span>.</p>
<p>I’ll refer you to take a look at <a href="#contingency">the section on contingency tables</a> which is basically a “two-way goodness of fit”.</p>
<!--
Before log-transforming, this is a one-way ANOVA:

$y = \beta_1*x_1 + \beta_2*x_2 + \beta_3*x_3 +... \qquad \mathcal{H}_0: y = \beta_1$

We should think of these as proportions of $sum(y)$ for reasons that will be clearer in [the section on contingency tables](#contingency):

$y = N\beta_1*x_1/N + N\beta_2*x_2/N + N\beta_3*x_3/N + ...$

But we fit parameters on the log_transformed model (ignoring the proportion-notation for now):

$log(y) = log(\beta_1*x_1 + \beta_2*x_2 + \beta_3*x_3 +...) \qquad \mathcal{H}_0: log(y) = log(\beta_1)$

$log(y) = log(N\beta_1*x_1/N + N)$
-->
</div>
<div id="example-data-1" class="section level3">
<h3><span class="header-section-number">7.1.2</span> Example data</h3>
<p>For this, we need some wide count data:</p>
<pre class="r"><code># Data in long format
D = data.frame(mood = c(&#39;happy&#39;, &#39;sad&#39;, &#39;meh&#39;),
               counts = c(60, 90, 70))

# Dummy coding for the linear model
D$mood_happy = ifelse(D$mood == &#39;happy&#39;, 1, 0)
D$mood_sad = ifelse(D$mood == &#39;sad&#39;, 1, 0)</code></pre>
<div id="htmlwidget-60bdda8eeaa4563fd3e1" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-60bdda8eeaa4563fd3e1">{"x":{"filter":"none","data":[["happy","sad","meh"],[60,90,70],[1,0,0],[0,1,0]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>mood<\/th>\n      <th>counts<\/th>\n      <th>mood_happy<\/th>\n      <th>mood_sad<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
</div>
<div id="r-code-goodness-of-fit" class="section level3">
<h3><span class="header-section-number">7.1.3</span> R code: Goodness of fit</h3>
<p>Now let’s see that the Goodness of fit is just a log-linear equivalent to a one-way ANOVA. We set <code>family = poisson()</code> which defaults to setting a logarithmic <a href="https://en.wikipedia.org/wiki/Generalized_linear_model#Link_function">link function</a> (<code>family = poisson(link='log')</code>).</p>
<pre class="r"><code># Built-in test
a = chisq.test(D$counts)

# As log-linear model, comparing to an intercept-only model
full = glm(counts ~ 1 + mood_happy + mood_sad, data=D, family=poisson())
null = glm(counts ~ 1, data=D, family=poisson())
b = anova(null, full, test=&#39;Rao&#39;)

# Note: glm can also do the dummy coding for you:
c = glm(counts ~ mood, data=D, family=poisson())</code></pre>
<p>Let’s look at the results:</p>
<div id="htmlwidget-2df5675aded0e9696612" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-2df5675aded0e9696612">{"x":{"filter":"none","data":[["chisq.test","glm LRT"],[6.3636,6.3636],[2,2],[0.0415,0.0415]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>Chisq<\/th>\n      <th>df<\/th>\n      <th>p.value<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Chi-squared test for given probabilities
## 
## data:  D$counts
## X-squared = 6.3636, df = 2, p-value = 0.04151
## 
## Analysis of Deviance Table
## 
## Model 1: counts ~ 1
## Model 2: counts ~ 1 + mood_happy + mood_sad
##   Resid. Df Resid. Dev Df Deviance    Rao Pr(&gt;Chi)  
## 1         2     6.2697                              
## 2         0     0.0000  2   6.2697 6.3636  0.04151 *
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
<p>Note the strange <code>anova(..., test='Rao')</code> which merely states that p-values should be computed using the (Rao) <a href="https://en.wikipedia.org/wiki/Score_test">score test</a>. We could also have jotted in <code>test='Chisq'</code> or <code>test='LRT'</code> which would have yielded approximate p-values. You may think that we’re cheating here, sneaking in some sort of Chi-Square model post-hoc. However, <code>anova</code> only specifies how p-values are calculated whereas all the log-linear modeling happened in <code>glm</code>.</p>
<p>By the way, if there are only two counts and a large sample size (N &gt; 100), this model begins to approximate the <strong>binomial test</strong>, <code>binom.test</code>, to a reasonable degree. But this sample size is larger than most use cases, so I won’t raise to a rule-of-thumb and won’t dig deeper into it here.</p>
</div>
</div>
<div id="contingency" class="section level2">
<h2><span class="header-section-number">7.2</span> Contingency tables</h2>
<div id="theory-as-log-linear-model-1" class="section level3">
<h3><span class="header-section-number">7.2.1</span> Theory: As log-linear model</h3>
<p>The theory here will be a bit more convoluted, and I mainly write it up so that you can get the <em>feeling</em> that it really is just a log-linear <a href="#anova2">two-way ANOVA model</a>. Let’s get started…</p>
<p>For a two-way contingency table, the model of the count variable <span class="math inline">\(y\)</span> is a modeled using the marginal proportions of a contingency table. Why this makes sense, is too involved to go into here, but <a href="https://www.uni-tuebingen.de/fileadmin/Uni_Tuebingen/SFB/SFB_833/A_Bereich/A1/Christoph_Scheepers_-_Statistikworkshop.pdf">see the relevant slides by Christoph Scheepers here</a> for an excellent exposition. The model is composed of a lot of counts and the regression coefficients <span class="math inline">\(A_i\)</span> and <span class="math inline">\(B_i\)</span>:</p>
<p><span class="math inline">\(y_i = N \cdot x_i(A_i/N) \cdot z_j(B_j/N) \cdot x_{ij}/((A_i x_i)/(B_j z_j)/N)\)</span></p>
<p>What a mess!!! Here, <span class="math inline">\(i\)</span> is the row index, <span class="math inline">\(j\)</span> is the column index, <span class="math inline">\(x_{something}\)</span> is the sum of that row and/or column, <span class="math inline">\(N = sum(y)\)</span>. Remember that <span class="math inline">\(y\)</span> is a count variable, so <span class="math inline">\(N\)</span> is just the total count.</p>
<p>We can simplify the notation by defining the <em>proportions</em>: <span class="math inline">\(\alpha_i = x_i(A_i/N)\)</span>, <span class="math inline">\(\beta_i = x_j(B_i/N)\)</span> and <span class="math inline">\(\alpha_i\beta_j = x_{ij}/(A_i x_i)/(B_j z_j)/N\)</span>. Let’s write the model again:</p>
<p><span class="math inline">\(y_i = N \cdot \alpha_i \cdot \beta_j \cdot \alpha_i\beta_j\)</span></p>
<p>Ah, much prettier. However, there is still lot’s of multiplication which makes it hard to get an intuition about how the actual numbers interact. We can make it much more intelligible when we remember that <span class="math inline">\(log(A \cdot B) = log(A) + log(B)\)</span>. Doing logarithms on both sides, we get:</p>
<p><span class="math inline">\(log(y_i) = log(N) + log(\alpha_i) + log(\beta_j) + log(\alpha_i\beta_j)\)</span></p>
<p>Snuggly! Now we can get a better grasp on how the regression coefficients (which are proportions) independently contribute to <span class="math inline">\(y\)</span>. This is why logarithms are so nice for proportions. Note that this is just <a href="#anova2">the two-way ANOVA model</a> with some logarithms added, so we are back to our good old linear models - only the interpretation of the regression coefficients have changed! And we cannot use <code>lm</code> anymore in R.</p>
</div>
<div id="example-data-2" class="section level3">
<h3><span class="header-section-number">7.2.2</span> Example data</h3>
<p>Here we need some long data and we need it in table format for <code>chisq.test</code>:</p>
<pre class="r"><code># Contingency data in long format for linear model
D = data.frame(mood = c(&#39;happy&#39;, &#39;happy&#39;, &#39;meh&#39;, &#39;meh&#39;, &#39;sad&#39;, &#39;sad&#39;),
               sex = c(&#39;male&#39;, &#39;female&#39;, &#39;male&#39;, &#39;female&#39;, &#39;male&#39;, &#39;female&#39;),
               Freq = c(100, 70, 30, 32, 110, 120))

# ... and as table for chisq.test
D_table = D %&gt;% 
  spread(key=mood, value=Freq) %&gt;%  # Mood to columns
  select(-sex) %&gt;%  # Remove sex column
  as.matrix()

# Dummy coding of D for linear model (skipping mood==&quot;sad&quot; and gender==&quot;female&quot;)
# We could also use model.matrix(D$Freq~D$mood*D$sex)
D$mood_happy = ifelse(D$mood == &#39;happy&#39;, 1, 0)
D$mood_meh = ifelse(D$mood == &#39;meh&#39;, 1, 0)
D$sex_male = ifelse(D$sex == &#39;male&#39;, 1, 0)</code></pre>
<div id="htmlwidget-2e7e1fc6d3321085ef8e" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-2e7e1fc6d3321085ef8e">{"x":{"filter":"none","data":[["happy","happy","meh","meh","sad","sad"],["male","female","male","female","male","female"],[100,70,30,32,110,120],[1,1,0,0,0,0],[0,0,1,1,0,0],[1,0,1,0,1,0]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>mood<\/th>\n      <th>sex<\/th>\n      <th>Freq<\/th>\n      <th>mood_happy<\/th>\n      <th>mood_meh<\/th>\n      <th>sex_male<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
</div>
<div id="r-code-chi-square-test" class="section level3">
<h3><span class="header-section-number">7.2.3</span> R code: Chi-square test</h3>
<p>Now let’s show the equivalence between a chi-square model and a log-linear model. This is very similar to our <a href="#anova2">two-way ANOVA</a> above:</p>
<pre class="r"><code># Built-in chi-square. It requires matrix format.
a = chisq.test(D_table)

# Using glm to do a log-linear model, we get identical results when testing the interaction term:
full = glm(Freq ~ 1 + mood_happy + mood_meh + sex_male + mood_happy*sex_male + mood_meh*sex_male, data=D, family=poisson())
null = glm(Freq ~ 1 + mood_happy + mood_meh + sex_male, data=D, family=poisson())
b = anova(null, full, test=&#39;Rao&#39;)  # Could also use test=&#39;LRT&#39; or test=&#39;Chisq&#39;

# Note: let glm do the dummy coding for you
full = glm(Freq ~ mood * sex, family=poisson(), data=D)
c = anova(full, test=&#39;Rao&#39;)

# Note: even simpler syntax using MASS:loglm (&quot;log-linear model&quot;)
d = MASS::loglm(Freq ~ mood + sex, D)</code></pre>
<div id="htmlwidget-33a25016cc63415bbb63" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-33a25016cc63415bbb63">{"x":{"filter":"none","data":[["chisq.test","glm","loglm"],[5.0999,5.0999,5.0999],[2,2,2],[0.0781,0.0781,0.0781]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th>model<\/th>\n      <th>Chisq<\/th>\n      <th>df<\/th>\n      <th>p.value<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"searching":false,"lengthChange":false,"ordering":false,"autoWidth":true,"bPaginate":false,"bInfo":false,"paging":false,"columnDefs":[{"className":"dt-right","targets":[1,2,3]}],"order":[],"orderClasses":false}},"evals":[],"jsHooks":[]}</script>
<div class="fold o">
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  D_table
## X-squared = 5.0999, df = 2, p-value = 0.07809
## 
## Analysis of Deviance Table
## 
## Model 1: Freq ~ 1 + mood_happy + mood_meh + sex_male
## Model 2: Freq ~ 1 + mood_happy + mood_meh + sex_male + mood_happy * sex_male + 
##     mood_meh * sex_male
##   Resid. Df Resid. Dev Df Deviance    Rao Pr(&gt;Chi)  
## 1         2     5.1199                              
## 2         0     0.0000  2   5.1199 5.0999  0.07809 .
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Analysis of Deviance Table
## 
## Model: poisson, link: log
## 
## Response: Freq
## 
## Terms added sequentially (first to last)
## 
## 
##          Df Deviance Resid. Df Resid. Dev    Rao Pr(&gt;Chi)    
## NULL                         5    111.130                    
## mood      2  105.308         3      5.821 94.132  &lt; 2e-16 ***
## sex       1    0.701         2      5.120  0.701  0.40235    
## mood:sex  2    5.120         0      0.000  5.100  0.07809 .  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Call:
## MASS::loglm(formula = Freq ~ mood + sex, data = D)
## 
## Statistics:
##                       X^2 df   P(&gt; X^2)
## Likelihood Ratio 5.119915  2 0.07730804
## Pearson          5.099859  2 0.07808717
## 
## Call:
## glm(formula = Freq ~ mood * sex, family = poisson(), data = D)
## 
## Deviance Residuals: 
## [1]  0  0  0  0  0  0
## 
## Coefficients:
##                 Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)       4.2485     0.1195  35.545  &lt; 2e-16 ***
## moodmeh          -0.7828     0.2134  -3.668 0.000244 ***
## moodsad           0.5390     0.1504   3.584 0.000339 ***
## sexmale           0.3567     0.1558   2.289 0.022094 *  
## moodmeh:sexmale  -0.4212     0.2981  -1.413 0.157670    
## moodsad:sexmale  -0.4437     0.2042  -2.172 0.029819 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for poisson family taken to be 1)
## 
##     Null deviance: 1.1113e+02  on 5  degrees of freedom
## Residual deviance: 3.9968e-15  on 0  degrees of freedom
## AIC: 48.254
## 
## Number of Fisher Scoring iterations: 3</code></pre>
</div>
<p>If you unfold the raw R output, I’ve included <code>summary(full)</code> so that you can see the raw regression coefficients. Being a log-linear model, these are the <em>percentage increase</em>in <span class="math inline">\(y\)</span> over and above the intercept if that category obtains.</p>
</div>
</div>
</div>
<div id="links" class="section level1">
<h1><span class="header-section-number">8</span> Sources and further equivalences</h1>
<p>Here are links to other sources who have exposed bits and pieces of this puzzle, including many further equivalences not covered here:</p>
<ul>
<li><a href="https://stats.stackexchange.com/questions/303269/common-statistical-tests-as-linear-models">My original exposition of the idea</a> at StackOverflow</li>
<li><a href="https://stats.stackexchange.com/questions/210529/are-parametric-tests-on-rank-transformed-data-equivalent-to-non-parametric-test?noredirect=1#comment399981_210529">An earlier question by me</a> about non-parametric tests and a helpful answer.</li>
<li><a href="https://stats.stackexchange.com/questions/59047/how-are-regression-the-t-test-and-the-anova-all-versions-of-the-general-linear">This question and replies</a> on t-tests and ANOVA at StackOverflow</li>
<li><a href="https://www.uni-tuebingen.de/fileadmin/Uni_Tuebingen/SFB/SFB_833/A_Bereich/A1/Christoph_Scheepers_-_Statistikworkshop.pdf">These slides by Christoph Scheepers</a> on Chi-Square as log-linear models.</li>
<li><a href="https://rpubs.com/palday/glm-test">This notebook by Philip M. Alday</a> on Chi-square, binomial, multinomial, and poisson tests as log-linear and logistic models. These “equivalences” are less exact than what I presented above, and were therefore not included here. They are still great for a conceptual understanding of these tests, though!</li>
<li><a href="https://rpsychologist.com/r-guide-longitudinal-lme-lmer">This article by Kristoffer Magnusson</a> on RM-ANOVA and growth models using <code>lmer</code> mixed models.</li>
<li><a href="https://seriousstats.wordpress.com/2012/02/14/friedman/">This post by Thom Baguley</a> on the Friedman test. That post was actually the one that inititated my exploration of linear equivalences to non-parametric tests which ultimately pushed me over the edge to write up the present article.</li>
</ul>
</div>
<div id="course" class="section level1">
<h1><span class="header-section-number">9</span> Teaching materials and a course outline</h1>
<p>Most advanced stats books (and some intro-books) take the “everything is GLMM” approach as well. However, the “linear model” part often stay at the conceptual level. I wanted to make linear models the <em>tool</em> in a really concise way. Luckily, more beginner-friendly materials have emerged lately:</p>
<ul>
<li>Russ Poldracks open-source book “Statistical Thinking for the 21st century” (start at <a href="http://statsthinking21.org/fitting-models-to-data.html">chapter 5 on modeling</a>)</li>
<li><a href="https://jeffrouder.blogspot.com/2019/03/teaching-undergrad-stats-without-p-f-or.html">Jeff Rouder’s course notes</a>, introducing model comparison using just <span class="math inline">\(R^2\)</span> and BIC. It avoids all the jargon on p-values, F-values, etc. The full materials and slides <a href="https://drive.google.com/drive/folders/1CiJK--bAuO0F-ug3B5I3FvmsCdpPGZ03">are available here</a>.</li>
</ul>
<p>Here are my own thoughts on what I’d do. I’ve done parts of this with great success already, but not the whole lot since I’m not assigned to do a full course yet.</p>
<p>I would spend 50% of the time on linear modeling of data (bullet 1 below) since this contains 70% of what students need to know. The rest of the course is just fleshing out what happens if you have one group, two groups, etc.</p>
<p>Note that whereas the understanding of sampling and hypothesis testing is usually the first focus of mainstream stats courses, it is saved for later here to make way for modeling.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Fundamentals of regression:</strong></p>
<ol style="list-style-type: decimal">
<li><p>Recall from high-school: <span class="math inline">\(y = a \cdot x + b\)</span>, and getting a really good intuition about slopes and intercepts. Understanding that this can be written using all variable names, e.g., <code>money = profit * time + starting_money</code> or <span class="math inline">\(y = \beta_1x + \beta_2*1\)</span> or, suppressing the coefficients, as <code>y ~ x + 1</code>. If the audience is receptive, convey the idea of these models <a href="https://magesblog.com/post/modelling-change">as a solution to differential equations</a>, specifying how <span class="math inline">\(y\)</span> <em>changes</em> with <span class="math inline">\(x\)</span>.</p></li>
<li><p>Extend to a few multiple regression as models. Make sure to include plenty of real-life examples and exercises at this point to make all of this really intuitive. Marvel at how briefly these models allow us to represent large datasets.</p></li>
<li><p>Introduce the idea of rank-transforming non-metric data and try it out.</p></li>
<li><p>Teach the three assumptions: independence of data points, normality of residuals, and homoscedasticity.</p></li>
<li><p>Confidence/credible intervals on the parameters. Stress that the Maximum-Likelihood estimate is extremely unlikely, so intervals are more important.</p></li>
<li><p>Briefly introduce <span class="math inline">\(R^2\)</span> for the simple regression models above. Mention in passing that this is called <a href="#correlation">the Pearson and Spearman correlation coefficients</a>.</p></li>
</ol></li>
<li><p><strong>Special case #1: One or two means (t-tests, Wilcoxon, Mann-Whitney):</strong></p>
<ol style="list-style-type: decimal">
<li><p><strong>One mean:</strong> When there is only one x-value, the regression model simplifies to <span class="math inline">\(y = b\)</span>. If <span class="math inline">\(y\)</span> is non-metric, you can rank-transform it. Apply the assumptions (homoscedasticity doesn’t apply since there is only one <span class="math inline">\(x\)</span>). Mention in passing that these intercept-only models are called <a href="#t1">one-sample t-test and Wilcoxon Signed Rank test respectively</a>.</p></li>
<li><p><strong>Two means:</strong> If we put two variables 1 apart on the x-axis, the difference between the means is the slope. Great! It is accessible to our swizz army knife called linear modeling. Apply the assumption checks to see that homoscedasticity reduces to equal variance between groups. This is called an <a href="#t2">independent t-test</a>. Do a few worked examples and exercises, maybe adding Welch’s test, and do the rank-transformed version, called Mann-Whitney U.</p></li>
<li><p><em>Paired samples:</em> Violates the independence assumption. After computing pairwise differences, this is equivalent to 2.1 (one intercept), though it is called the <a href="#tpair">paired t-test and Wilcoxon’s matched pairs</a>.</p></li>
</ol></li>
<li><p><strong>Special case #2: Three or more means (ANOVAs)</strong></p>
<ol style="list-style-type: decimal">
<li><p><em><a href="#dummy">Dummy coding</a> of categories:</em> How one regression coefficient for each level of a factor models an intercept for each level when multiplied by a binary indicator. This is just extending what we did in 2.1. to make this data accessible to linear modeling.</p></li>
<li><p><em>Means of one variable:</em> <a href="#anova1">One-way ANOVA</a>.</p></li>
<li><p><em>Means of two variables:</em> <a href="#anova2">Two-way ANOVA</a>.</p></li>
</ol></li>
<li><p><strong>Special case #3: Three or more proportions (Chi-Square)</strong></p>
<ol style="list-style-type: decimal">
<li><p><em>Logarithmic transformation:</em> Making multiplicative models linear using logarithms, thus modeling proportions. See <a href="https://www.uni-tuebingen.de/fileadmin/Uni_Tuebingen/SFB/SFB_833/A_Bereich/A1/Christoph_Scheepers_-_Statistikworkshop.pdf">this excellent introduction</a> to the equivalence of log-linear models and Chi-Square tests as models of proportions. Also needs to introduce (log-)odds ratios. When the multiplicative model is made summative using logarithms, we just add the dummy-coding trick from 3.1, and see that the models are identical to the ANOVA models in 3.2 and 3.3, only the interpretation of the coefficients have changed.</p></li>
<li><p><em>Proportions of one variable:</em> <a href="#goodness">Goodness of fit</a>.</p></li>
<li><p><em>Proportions of two variables:</em> <a href="#contingency">Contingency tables</a>.</p></li>
</ol></li>
<li><p><strong>Hypothesis testing:</strong> Hypothesis testing is the act of choosing between a full model and one where a parameter is set to zero (effectively excluded from the model) instead of being estimated. For example, when set one of the two means in the t-test to be zero, we study how well the remaining mean explains all the data from both groups. If it does a good job, we prefer this model over the two-mean model because it is simpler. So hypothesis testing is just comparing linear models to make more qualitative statements than the truly quantitative statements which were covered in bullets 1-4 above. Therefore, hypothesis testing is less interesting and is mostly covered as an introduction to the general literature. Mention P-values (and misconceptions about them), Bayes Factors, and cross-validation.</p></li>
</ol>
</div>
<div id="limitations" class="section level1">
<h1><span class="header-section-number">10</span> Limitations</h1>
<p>I have made a few simplifications for clarity:</p>
<ol style="list-style-type: decimal">
<li><p>I have not covered assumptions in the examples. This will be another post! But all assumptions of all tests come down to the usual three: a) independence of data points, b) normally distributed residuals, and c) homoscedasticity.</p></li>
<li><p>I assume that all null hypotheses are the absence of an effect, but everything works the same for non-zero null hypotheses.</p></li>
<li><p>I have not discussed inference. I am only including p-values in the comparisons as a crude way to show the equivalences between the underlying models since people care about p-values. Parameter estimates will show the same equivalence. How to do <em>inference</em> is another matter. Personally, I’m a Bayesian, but going Bayesian here would render it less accessible to the wider audience. Also, doing <a href="https://en.wikipedia.org/wiki/Robust_statistics">robust models</a> would be preferable, but fail to show the equivalence.</p></li>
<li><p>Several named tests are still missing from the list and may be added at a later time. This includes the Sign test (require large N to be reasonably approximated by a linear model), Friedman as RM-ANOVA on <code>rank(y)</code>, McNemar, and Binomial/Multinomial. See stuff on these in <a href="#links">the section on links to further equivalences</a>. If you think that they should be included here, feel free to submit “solutions” to <a href="https://github.com/lindeloev/tests-as-linear/">the github repo</a> of this doc!</p></li>
</ol>
<!--
# Visualization of models (in progress)
These will eventually be included under the respective headers and in the infographic.
<img src="index_files/figure-html/unnamed-chunk-70-1.png" width="192" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-70-2.png" width="192" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-70-3.png" width="192" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-70-4.png" width="192" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-70-5.png" width="192" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-70-6.png" width="192" style="display: block; margin: auto;" />
-->
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
